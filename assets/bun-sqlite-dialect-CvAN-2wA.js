import{C as s,D as n,b as i,d as o,s as c}from"./entity-history-item.stories-BKXatT7r.js";import"./iframe-CIoATzkS.js";import"./preload-helper-PPVm8Dsz.js";import"./index-Bhq-d_bU.js";import"./index-CPuUOY1q.js";import"./index-Du96L6Ih.js";import"drizzle-orm";import"./date-CyM_0PVW.js";import"drizzle-orm/mysql2";import"mysql2/promise";import"./index-h3w6TyfV.js";import"./proxy-DSYwp9-I.js";import"./cx-BFURdk0p.js";import"./pixel-border-hQx-BoEX.js";var l=class{get supportsCreateIfNotExists(){return!0}get supportsTransactionalDdl(){return!1}get supportsReturning(){return!0}async acquireMigrationLock(){}async releaseMigrationLock(){}get supportsOutput(){return!0}},u=class{#e;#t=new p;#r;#a;constructor(e){this.#e={...e}}async init(){this.#r=this.#e.database,this.#a=new m(this.#r),this.#e.onCreateConnection&&await this.#e.onCreateConnection(this.#a)}async acquireConnection(){return await this.#t.lock(),this.#a}async beginTransaction(e){await e.executeQuery(s.raw("begin"))}async commitTransaction(e){await e.executeQuery(s.raw("commit"))}async rollbackTransaction(e){await e.executeQuery(s.raw("rollback"))}async releaseConnection(){this.#t.unlock()}async destroy(){this.#r?.close()}},m=class{#e;constructor(e){this.#e=e}executeQuery(e){const{sql:r,parameters:a}=e,t=this.#e.prepare(r);return Promise.resolve({rows:t.all(a)})}async*streamQuery(){throw new Error("Streaming query is not supported by SQLite driver.")}},p=class{#e;#t;async lock(){for(;this.#e;)await this.#e;this.#e=new Promise(e=>{this.#t=e})}unlock(){const e=this.#t;this.#e=void 0,this.#t=void 0,e?.()}},h=class{#e;constructor(e){this.#e=e}async getSchemas(){return[]}async getTables(e={withInternalKyselyTables:!1}){let r=this.#e.selectFrom("sqlite_schema").where("type","=","table").where("name","not like","sqlite_%").select("name").$castTo();e.withInternalKyselyTables||(r=r.where("name","!=",i).where("name","!=",o));const a=await r.execute();return Promise.all(a.map(({name:t})=>this.#t(t)))}async getMetadata(e){return{tables:await this.getTables(e)}}async#t(e){const r=this.#e,a=(await r.selectFrom("sqlite_master").where("name","=",e).select("sql").$castTo().execute())[0]?.sql?.split(/[\(\),]/)?.find(t=>t.toLowerCase().includes("autoincrement"))?.split(/\s+/)?.[0]?.replace(/["`]/g,"");return{name:e,columns:(await r.selectFrom(c`pragma_table_info(${e})`.as("table_info")).select(["name","type","notnull","dflt_value"]).execute()).map(t=>({name:t.name,dataType:t.type,isNullable:!t.notnull,isAutoIncrementing:t.name===a,hasDefaultValue:t.dflt_value!=null})),isView:!0}}},y=class extends n{getCurrentParameterPlaceholder(){return"?"}getLeftIdentifierWrapper(){return'"'}getRightIdentifierWrapper(){return'"'}getAutoIncrement(){return"autoincrement"}},Q=class{#e;constructor(e){this.#e={...e}}createDriver(){return new u(this.#e)}createQueryCompiler(){return new y}createAdapter(){return new l}createIntrospector(e){return new h(e)}};export{Q as BunSqliteDialect};
