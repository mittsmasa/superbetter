import{c as N,s as S}from"./entity-history-item.stories-B9rpGJt5.js";import{a as re,g as ne}from"./entity-history-item.stories-B9rpGJt5.js";import"./iframe-DPlMxrgh.js";import"./preload-helper-PPVm8Dsz.js";import"./index-D57UY3lQ.js";import"./index-z439eqk_.js";import"./index-DbSxbZG6.js";import"drizzle-orm";import"./date-CyM_0PVW.js";import"drizzle-orm/mysql2";import"mysql2/promise";import"./index-DjUInJ7f.js";import"./proxy-PjhcWVYS.js";import"./cx-BFURdk0p.js";import"./pixel-border-B1oUDgUn.js";const b=(F,m)=>{let O=null;const k=A=>({getFieldName:w,schema:I,getDefaultFieldName:G,getDefaultModelName:D,getFieldAttributes:L,getModelName:_})=>{const x=o=>{const u=[],i=[];if(o)for(const[n,r]of Object.entries(o)){const t=I[D(n)]?.fields,[e,a]=n.includes(".")?n.split("."):[void 0,n];if(t){t.id={type:"string"};for(const[s,p]of Object.entries(t))u.push(S`${S.ref(`join_${a}`)}.${S.ref(p.fieldName||s)} as ${S.ref(`_joined_${a}_${p.fieldName||s}`)}`),i.push({joinModel:n,joinModelRef:a,fieldName:p.fieldName||s})}}return{allSelectsStr:i,allSelects:u}},v=async(o,u,i,n)=>{let r;if(m?.type==="mysql"){await u.execute();const t=o.id?"id":n.length>0&&n[0]?.field?n[0].field:"id";if(!o.id&&n.length===0)return r=await A.selectFrom(i).selectAll().orderBy(w({model:i,field:t}),"desc").limit(1).executeTakeFirst(),r;const e=o[t]||n[0]?.value;return r=await A.selectFrom(i).selectAll().orderBy(w({model:i,field:t}),"desc").where(w({model:i,field:t}),"=",e).limit(1).executeTakeFirst(),r}return m?.type==="mssql"?(r=await u.outputAll("inserted").executeTakeFirst(),r):(r=await u.returningAll().executeTakeFirst(),r)};function M(o,u){if(!u)return{and:null,or:null};const i={and:[],or:[]};return u.forEach(n=>{const{field:r,value:t,operator:e="=",connector:a="AND"}=n,s=t,p=w({model:o,field:r}),y=f=>{const l=`${o}.${p}`;return e.toLowerCase()==="in"?f(l,"in",Array.isArray(s)?s:[s]):e.toLowerCase()==="not_in"?f(l,"not in",Array.isArray(s)?s:[s]):e==="contains"?f(l,"like",`%${s}%`):e==="starts_with"?f(l,"like",`${s}%`):e==="ends_with"?f(l,"like",`%${s}`):e==="eq"?f(l,"=",s):e==="ne"?f(l,"<>",s):e==="gt"?f(l,">",s):e==="gte"?f(l,">=",s):e==="lt"?f(l,"<",s):e==="lte"?f(l,"<=",s):f(l,e,s)};a==="OR"?i.or.push(y):i.and.push(y)}),{and:i.and.length?i.and:null,or:i.or.length?i.or:null}}function R(o,u,i){if(!u||!o.length)return o;const n=new Map;for(const t of o){const e={},a={};for(const[y]of Object.entries(u))a[_(y)]={};for(const[y,f]of Object.entries(t)){const l=String(y);let c=!1;for(const{joinModel:d,fieldName:h,joinModelRef:j}of i)if(l===`_joined_${j}_${h}`){a[_(d)][w({model:d,field:h})]=f,c=!0;break}c||(e[y]=f)}const s=e.id;if(!s)continue;if(!n.has(s)){const y={...e};for(const[f,l]of Object.entries(u))y[_(f)]=l.relation==="one-to-one"?null:[];n.set(s,y)}const p=n.get(s);for(const[y,f]of Object.entries(u)){const l=f.relation==="one-to-one",c=f.limit??100,d=a[_(y)],h=d&&Object.keys(d).length>0&&Object.values(d).some(j=>j!=null);if(l)p[_(y)]=h?d:null;else{const j=_(y);if(Array.isArray(p[j])&&h){if(p[j].length>=c)continue;const E=w({model:y,field:"id"}),T=d[E];T?!p[j].some(J=>J[E]===T)&&p[j].length<c&&p[j].push(d):p[j].length<c&&p[j].push(d)}}}}const r=Array.from(n.values());for(const t of r)for(const[e,a]of Object.entries(u))if(a.relation!=="one-to-one"){const s=_(e);if(Array.isArray(t[s])){const p=a.limit??100;t[s].length>p&&(t[s]=t[s].slice(0,p))}}return r}return{async create({data:o,model:u}){return await v(o,A.insertInto(u).values(o),u,[])},async findOne({model:o,where:u,select:i,join:n}){const{and:r,or:t}=M(o,u);let e=A.selectFrom(f=>{let l=f.selectFrom(o);return r&&(l=l.where(c=>c.and(r.map(d=>d(c))))),t&&(l=l.where(c=>c.or(t.map(d=>d(c))))),l.selectAll().as("primary")}).selectAll("primary");if(n)for(const[f,l]of Object.entries(n)){const[c,d]=f.includes(".")?f.split("."):[void 0,f];e=e.leftJoin(`${f} as join_${d}`,h=>h.onRef(`join_${d}.${l.on.to}`,"=",`primary.${l.on.from}`))}const{allSelectsStr:a,allSelects:s}=x(n);e=e.select(s);const p=await e.execute();if(!p||!Array.isArray(p)||p.length===0)return null;const y=p[0];return n?R(p,n,a)[0]:y},async findMany({model:o,where:u,limit:i,offset:n,sortBy:r,join:t}){const{and:e,or:a}=M(o,u);let s=A.selectFrom(l=>{let c=l.selectFrom(o);return m?.type==="mssql"?n!==void 0?(r||(c=c.orderBy(w({model:o,field:"id"}))),c=c.offset(n).fetch(i||100)):i!==void 0&&(c=c.top(i)):(i!==void 0&&(c=c.limit(i)),n!==void 0&&(c=c.offset(n))),r?.field&&(c=c.orderBy(`${w({model:o,field:r.field})}`,r.direction)),e&&(c=c.where(d=>d.and(e.map(h=>h(d))))),a&&(c=c.where(d=>d.or(a.map(h=>h(d))))),c.selectAll().as("primary")}).selectAll("primary");if(t)for(const[l,c]of Object.entries(t)){const[d,h]=l.includes(".")?l.split("."):[void 0,l];s=s.leftJoin(`${l} as join_${h}`,j=>j.onRef(`join_${h}.${c.on.to}`,"=",`primary.${c.on.from}`))}const{allSelectsStr:p,allSelects:y}=x(t);s=s.select(y),r?.field&&(s=s.orderBy(`${w({model:o,field:r.field})}`,r.direction));const f=await s.execute();return f?t?R(f,t,p):f:[]},async update({model:o,where:u,update:i}){const{and:n,or:r}=M(o,u);let t=A.updateTable(o).set(i);return n&&(t=t.where(e=>e.and(n.map(a=>a(e))))),r&&(t=t.where(e=>e.or(r.map(a=>a(e))))),await v(i,t,o,u)},async updateMany({model:o,where:u,update:i}){const{and:n,or:r}=M(o,u);let t=A.updateTable(o).set(i);n&&(t=t.where(a=>a.and(n.map(s=>s(a))))),r&&(t=t.where(a=>a.or(r.map(s=>s(a)))));const e=(await t.executeTakeFirst()).numUpdatedRows;return e>Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:Number(e)},async count({model:o,where:u}){const{and:i,or:n}=M(o,u);let r=A.selectFrom(o).select(A.fn.count("id").as("count"));i&&(r=r.where(e=>e.and(i.map(a=>a(e))))),n&&(r=r.where(e=>e.or(n.map(a=>a(e)))));const t=await r.execute();return typeof t[0].count=="number"?t[0].count:typeof t[0].count=="bigint"?Number(t[0].count):parseInt(t[0].count)},async delete({model:o,where:u}){const{and:i,or:n}=M(o,u);let r=A.deleteFrom(o);i&&(r=r.where(t=>t.and(i.map(e=>e(t))))),n&&(r=r.where(t=>t.or(n.map(e=>e(t))))),await r.execute()},async deleteMany({model:o,where:u}){const{and:i,or:n}=M(o,u);let r=A.deleteFrom(o);i&&(r=r.where(e=>e.and(i.map(a=>a(e))))),n&&(r=r.where(e=>e.or(n.map(a=>a(e)))));const t=(await r.executeTakeFirst()).numDeletedRows;return t>Number.MAX_SAFE_INTEGER?Number.MAX_SAFE_INTEGER:Number(t)},options:m}};let q=null;q={config:{adapterId:"kysely",adapterName:"Kysely Adapter",usePlural:m?.usePlural,debugLogs:m?.debugLogs,supportsBooleans:!(m?.type==="sqlite"||m?.type==="mssql"||m?.type==="mysql"||!m?.type),supportsDates:!(m?.type==="sqlite"||m?.type==="mssql"||!m?.type),supportsJSON:m?.type==="postgres",supportsArrays:!1,supportsUUIDs:m?.type==="postgres",transaction:m?.transaction?A=>F.transaction().execute(w=>A(N({config:q.config,adapter:k(w)})(O))):!1},adapter:k(F)};const $=N(q);return A=>(O=A,$(A))};export{re as createKyselyAdapter,ne as getKyselyDatabaseType,b as kyselyAdapter};
